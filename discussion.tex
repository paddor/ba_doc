% vim: ft=tex
\chapter{Discussion}
% TODO something like a SWOT analysis here (strengths, weaknesses, opportunities, threats)
% TODO general advice: be concise, brief, and specific
% TODO: modifications to the same DIM objects from different actors at the same time => one update will be lost, but consistency is still guaranteed

% TODO: maintainability (SOLID principles, composition over inheritance)
% TODO: additional goal: security of SCADA applications
% TODO: additional personal goal: how fallacies of distributed computing are handled


% performance improvements
%   * circumvent scrypt in test suite
%   * avoid regex, use bare strings if possible (s[s.rindex('@')+1..-1]
%   * test suite with profiling activated
% * future feature: DIM visibility: :federation, :node, :actor
%   - useful for supernode's last_seen (:node), currently an ivar in engine
%   - current choice of HA supernode's endpoints (:node)
% * when closing cases, the flag "all_cases" could fuck up
%   - especially with multiple nodes
%   - with single node: race condition, reply could contain a case (now closed) that was not shown in the UI => what to do?
%   - proposal: remove flag, always just send array of case IDs
% * maybe: model updates are sent to UI before authentication (TODO: tell Manu)
% * ideas:
%   - crystal for performance
%   - msgpack for safety, show benchmarks
%   - broadcast messages, signing, domain model level signature so snapshots can be relayed
% * IDEA for DEPLOYMENT
%   * 1 git repo per deployment
%   * keygen phase: on each node, gen key and git commit in fedrb file
%   * `roadster keygen FILE`
% * analysis of encrypted traffic is still possible (see CURVE zmq)
% * cleartext ZMTP commands
% * talk about factories (MsgPack packer/unpacker) and hook methods, template method

% TODO sign config file: => trash

\section{Value Added}
% TODO what's better than before

\section{Limitations}
% TODO identify potential limitations and weaknesses of the product
% limitation: to followed HA nodes in a layer aren't possible (middle layer with HA and supernode with HA) the problem is the diagonal approach (upstream)
% solution: share data over the bstar sockets and don't use the upstream with the diagonal approach
% weakness: message packages can be identified and if someone would capture the traffic it would be possible to assign the payload to the right
% message type. => solution: filled it with padding...
%  
Limitations imposed by the design and implementation of the new features are
discussed here.

\subsection{Federation}
\subsubsection{DIM replication}
Eventual consistency is guaranteed even in situations where multiple actors
modify the same DIM objects at roughly the same time. However, some updates
might get lost. In those cases, the last writer wins.


Subtree synchronization has not been implemented, as deemed as not necessary at
this moment. Replication performance is by far sufficient, with messages being
sent and received within 1 -- 3 milliseconds, and the space requirements of a
complete DIM was observed to be very small so far, being just a small number of
plain Ruby objects.

\subsubsection{Message routing}
% TODO: would have been easier if CORE had inter-node sockets itself, but: 
% seperation of concern would be injured and the core would be come a big fat monolythic class

\subsection{HA}
A HA cluster has to be complete (both nodes running) during initialization.
Otherwise, only primary node can start to serve requests; the backup node will not
do this.

% TODO refactoring ideas: HANode < Node
%  => root object in config

\subsection{Persistence replication}
Message traffic towards root node sums up because of persistence
replication. This should not be a problem because of \zmq's brilliant
message batching, so the real limit only given by the inter-node network links.

\section{Business Benefits}
Using the new federation capability, Roadster can be deployed in larger
environments, possibly replacing higher-level systems described in
\autoref{sec:scope:sys-integration}.

\section{Ideas for Improvement}
\subsection{High availability}
% TODO: opportunity: Only go active with enough votes
% bstar extension: not done because KISS

\subsection{Rolling upgrades}
% OPTIMIZE move to Discussion
An obvious side benefit of this comes into play with upgrades. Using the HA
cluster capability it is possible to perform rolling upgrades, meaning one HA
peer can be upgraded while the other one stays in service. After a successful
upgrade, Roadster on the active peer can be stopped, upgraded, and restarted as
the passive peer.


\subsubsection{Thoughtful heartbeating}\label{sec:discussion:imp:ha:hb}
The BSTAR actor currently happily exchanges heartbeats with the BSTAR actor
running on the other HA peer, even in case all actors but CORE are dead. The
CORE actor's health is periodically checked using the PING/PONG mechanism as
described in \autoref{sec:approach:ha:hb}.

In a subsequent version of Roadster, the CORE actor could relay those PING
requests to the other actors and only respond with a PONG in case the other
actors all have responded with PONG. This mechanism would make the node only
signal life signs in case all actors are healthy.

\subsubsection{HA within a node}
Building upon the previous idea, unhealthy actors could be killed and respawned
by the CORE actor.  Microrebooting unhealthy components without an attempt at
any sophisticated recovery would make Roadster belong to the \emph{crash-only} kind of fault-tolerant software.

\subsubsection{Manual failover}\label{sec:discussion:ha:manual-failover}
A manually induced failover could be useful in some cases, e.g. when a
component fails that does not provoke an automatic failover.

Providing a less brutal way of inducing a failover than to turn off the
currently active HA peer could be interesting in a future version.

\subsubsection{Unplanned topologies}
% TODO
HA cluster can't have supernode right now, because upstream's DEALER socket
can't decide which node receives a message sent.
% Solution 1: ROUTER-ROUTER communication between node and subnodes.
% Solution 2: Refactor:
%   - rename Engines::BStar into Engines::Sidestream
%   - publish CSP updates over PUB socket as well (just like from Downstream->Upstream)
%   - add DEALER socket (DEALER-DEALER communication works)
%   - PUSH/PULL socket not needed because passive won't change DIM
%   - primary always binds, backup always connects
%   - => Upstream/Downstream are back to a single responsibility only
%   - => Upstream does not even have to be started on HA nodes
%   - => Downstream only needs to be started with subnodes

\subsection{Miscellaneous}
% TODO check IEEE abstract.. we need a refrence from IEEE as a idea for future features
http://ieeexplore.ieee.org/abstract/document/1541189/ Dynamic distributed computing would allow a Roadster federation to grow without to restart each of then nodes.
http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7190458 When a roadster have to calculate a high amount of data, it could be outsourced to other nodes which have free cpu.
Therefore would be a Data Mining Algorithm a good solution.

Unordered list of ideas:
\begin{itemize}
	\item switch to Moneta for a unified key-value store interface, then eventually away from \gls{tc} to something more modern and maintained, like LMDB (it is super fast and crash-proof)
	\item TIPC: high performance cluster communication protocol, suitable because Roadster nodes are Linux and there are direct links to peers (required for TIPC)
	\item key management in a DB (instead of files), with GUI to accept new clients
	\item dynamic node topology (maybe via DSL-file in Etcd, or DIM-only, or Zookeeper)
	\item other method for data serialization (like MessagePack), would allow adding other programming languages to the cluster
	\item fast compression for messages, like LZ4 or Snappy
	\item SERVER/CLIENT sockets from ZMQ 4.2 for simplified message routing
	\item Ruby \rb{Integer} class instead of \rb{Fixnum}
	\item (use more symbols instead of strings, e.g. to refer to a certain actor)
	\item \sh{ZMQ_RECONNECT_IVL} and \sh{ZMQ_RECONNECT_IVL_MAX} especially for mobile clients
\end{itemize}

